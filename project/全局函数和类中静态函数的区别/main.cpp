
using namespace std;

/**
 * 代码区：
 *     存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。
 *
 * data区:
 *     data区里主要存放的是已经初始化的全局变量、静态变量和常量
 *
 * bss区:
 *     bss区主要存放的是未初始化的全局变量、静态变量，这些未初始化的数据在程序执行前会自动被系统初始化为0或者NULL
 *
 * 常量区:
 *     常量区是全局区中划分的一个小区域，里面存放的是常量，如const修饰的全局变量、字符串常量等
 *
 * stack区:
 *     栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。
 *
 * heap区:
 *     堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。
 *
 *
 * 编译过程:
 * 预处理:
 *      g++ -E main.cpp -o main.ii，-E表示只进行预处理。
 *          预处理主要是处理各种宏展开；
 *          添加行号和文件标识符，为编译器产生调试信息提供便利；
 *          删除注释；
 *          保留编译器用到的编译器指令等。
 *
 * 编译:
 *      g++ -S main.ii –o main.s，-S表示只编译。
 *      编译是在预处理文件基础上经过一系列词法分析、语法分析及优化后生成汇编代码。
 *
 *      全局的函数被编译为: __Z11printWeightv:
 *      main也是全局函数，被编译为: _main:
 *      类中的函数被编译为: __ZN3Mas11printWeightEv:
 *
 *      在主函数的调用也是不同的
 *          callq	__ZN3Mas11printWeightEv
 *          callq	__Z11printWeightv
 *
 * 汇编:
 *      g++ -c main.s –o main.o。汇编是将汇编代码转化为机器可以执行的指令。
 *
 * 链接:
 *      g++ main.o。
 *      链接生成可执行程序，之所以需要链接是因为我们代码不可能像main.cpp这么简单，
 *      现代软件动则成百上千万行，如果写在一个main.cpp既不利于分工合作，也无法维护，因此通常是由一堆cpp文件组成，编译器分别编译每个cpp，这些cpp里会引用别的模块中的函数或全局变量，
 *      在编译单个cpp的时候是没法知道它们的准确地址，因此在编译结束后，需要链接器将各种还没有准确地址的符号（函数、变量等）设置为正确的值，这样组装在一起就可以形成一个完整的可执行程序。
 */

#define XXX 10

class Mas {
public:
    static void printWeight() {}

private:
    int weight;
};

void printWeight() {}

int main(int argc, const char *argv[]) {
    int x = XXX;

    Mas mas;
    mas.printWeight();

    printWeight();

    return 0;
}

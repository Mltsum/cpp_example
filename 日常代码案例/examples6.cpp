#include <iostream>
#include <array>
#include <memory>

/*
 * 强制转换运算符
 *  const_cast<type>(exp) : 用来更改const和volatile属性的
 *  static_cast<type>(exp) : 静态转换，非运行时的强制转换，没有运行时类检查来保护转换的安全性
 *
 */

/**
 *
 * 为什么? 强制类型转换是有一定风险的，有的转换并不一定安全，例如把int整形数值转换成一个指针类型，把基类指针转换成派生类指针的时候有可能会失败，把一种函数指针转换成另一种函数指针可能会出现不匹配的情况，把常量指针转换成非常量指针可能会导致原始常量被破坏等等并不是很安全的。
 * 所以: C++ 引入了四种功能不同的强制类型转换运算符以进行强制类型转换
 *
 * 解决了以下问题:
 * 1) 没有从形式上体现转换功能和风险的不同。 2) 将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。
 *
 * 强制类型转换运算符 <要转换到的类型> (待转换的表达式)
 *
 * static_cast: 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换;  不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。
 * dynamic_cast:  用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。
 * reinterpret_cast:用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换，reinterpret_cast 转换时，执行的过程是逐个比特复制的操作。
 * const_cast: const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符; 将 const 引用转换为同类型的非 const 引用，将 const 指针转换为同类型的非 const 指针时可以使用 const_cast 运算符
 */

#include <io.h>
#include <string>

using namespace std;

int main(){
    float f = 0.12345;
    cout << static_cast<int>(f) << endl;

//    cout << dynamic_cast<int>(f) << endl;
}